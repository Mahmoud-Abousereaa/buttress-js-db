<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="buttress-db-query">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    /**
     * `buttress-db-query`
     * #
     *
     * @customElement
     * @polymer
     */
    class ButtressDbQuery extends Polymer.Element {
      static get is() { return 'buttress-db-query'; }
      static get properties() {
        return {
          logLabel: {
            type: Number,
            value: 'db-query'
          },
          db: {
            type: Object
          },
          doc: {
            type: Object,
            notify: true
          },
          numResults: {
            type: Number,
            value: 0,
            notify: true
          },
          numPages: {
            type: Number,
            value: 0,
            notify: true
          },
          page: {
            type: Number,
            value: 1
          },
          limit: {
            type: Number,
            value: 50
          },
          findOne: {
            type: Object,
            notify: true
          },
          findAll: {
            type: Array,
            notify: true
          },
          findAllUnpaged: {
            type: Array,
            notify: true
          },
          query: {
            type: Object,
          },
          fields: {
            type: Array,
          },
          sort: {
            type: Array
          },

          paused: {
            type: Boolean,
            value: false
          }
        };
      }
      static get observers() {
        return [
          '__query(query.*, page, limit, paused)',
          '__docStatus(doc, doc.loaded)'
        ];
      }

      __docStatus() {
        if (!this.doc.loaded) {
          console.log('silly', '__docStatus', this.doc.status, this.doc);
          return;
        }

        console.log('silly', '__docStatus', 'doc.status', this.doc.status);

        if (this.query) {
          console.log('silly', '__docStatus', 'query', this.query);
          this.set('query.__loaded', true);
        }
      }
      __query() {
        console.log('debug', '__query', this.query);
        if (!this.query) {
          console.log('silly', '__query', 'no query');
          return;
        }
        if (!this.doc || !this.doc.loaded) {
          console.log('debug', '__query', 'no doc');
          return;
        }
        if (this.get('paused') === true) {
          console.log('silly', '__query', 'Paused');
          return;
        }

        let data = this.doc.data;
        console.log('silly', data);
        data = this.__processQuery(this.query, data);
        console.log('silly', data);

        if (this.limit > 0) {
          this.set('numPages', Math.ceil(data.length / this.limit));
          this.set('numResults', data.length);
          this.set('findAllUnpaged', data.concat([]));

          console.log('silly', this.page, this.limit, this.numPages);
          data = data.splice((this.page-1) * this.limit, this.limit);
          console.log('debug', data);
        }

        this.set('findAll', data);
        data.forEach((d, idx) => {
          let dataIndex = this.doc.data.indexOf(d);

          this.unlinkPaths(`findAll.#${idx}`);
          if (dataIndex !== -1) {
            this.linkPaths(`findAll.#${idx}`, `doc.data.#${dataIndex}`);
            console.log('silly', `Query: findAll.#${idx} linked to doc.data.#${dataIndex}`);
          }
        });

        let dataIndex = data.length > 0 ? this.doc.data.indexOf(data[0]): -1;
        this.set('findOne', data.length > 0 ? data[0] : null);

        this.unlinkPaths('findOne');
        if (dataIndex !== -1) {
          this.linkPaths('findOne', `doc.data.#${dataIndex}`);
          console.log('silly', `Query: findOne linked to doc.data.#${dataIndex}`);
        }

        console.log('silly', this.findOne);
      }

      __processQuery(query, data) {
        let outData = [].concat(data);

        for (let field in query) {
          if (!query.hasOwnProperty(field)) {
            continue;
          }

          if (field === '$and') {
            query[field].forEach(o => {
              outData = this.__processQuery(o, outData);
            });
            continue;
          }

          if (field === '$or') {
            outData = query[field]
              .map(o => this.__processQuery(o, outData))
              .reduce((combined, results) => {
                return combined.concat(results.filter(r => combined.indexOf(r) === -1));
              }, []);

            continue;
          }

          let command = query[field];
          for (let operator in command) {
            if (!command.hasOwnProperty(operator)) {
              continue;
            }

            let operand = command[operator];
            outData = this.__executeQuery(outData, field, operator, operand);
          }
        }
        return outData;
      }

      __executeQuery(data, field, operator, operand) {
        const __parsePath = (obj, path) => {
          let split = path.split('.');
          return split.reduce((o, key) => {
            if (!o) return [];
            console.log('silly', typeof o[key], o instanceof Array); 
            if (o instanceof Array && typeof o[key] === 'undefined') {
              return o.reduce((res, p) => {
                if (!p[key]) return res;
                res.push(p[key]);
                return res;
              }, []);
            }

            return o[key] === null || Array.isArray(o[key]) === false ? [o[key]] : o[key];
          }, obj);
        };

        let fns = {
          $not: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val !== rhs) !== -1,
          $eq: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val === rhs) !== -1,
          $gt: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val > rhs) !== -1,
          $lt: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val < rhs) !== -1,
          $gte: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val >= rhs) !== -1,
          $lte: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val <= rhs) !== -1,
          $rex: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => (new RegExp(rhs)).test(val)) !== -1,
          $rexi: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => (new RegExp(rhs, 'i')).test(val)) !== -1,
          $in: (rhs) => (lhs) => rhs.indexOf(lhs[field]) !== -1,
          $nin: (rhs) => (lhs) => rhs.indexOf(lhs[field]) === -1,
          $exists: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => val === undefined) === -1 === rhs,
          $inProp: (rhs) => (lhs) => lhs[field].indexOf(rhs) !== -1,
          $elMatch: (rhs) => (lhs) => this.__processQuery(rhs, __parsePath(lhs, field)).length > 0,
          $gteDate: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => Sugar.Date.isAfter(Sugar.Date.create(val), rhs) || val === rhs) !== -1,
          $lteDate: (rhs) => (lhs) => __parsePath(lhs, field).findIndex(val => Sugar.Date.isBefore(Sugar.Date.create(val), rhs) || val === rhs) !== -1,
        };

        if (!fns[operator]) {
          this.__err(new Error(`Invalid operator: ${operator}`));
          return [];
        }

        let results = data.filter(fns[operator](operand));
        console.log('debug', '__executeQuery', field, operator, operand, data.length, results.length);

        return results;
      }
    }
    window.customElements.define(ButtressDbQuery.is, ButtressDbQuery);
  </script>
</dom-module>
