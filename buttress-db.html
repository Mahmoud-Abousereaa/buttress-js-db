<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="./buttress-db-data-service.html">
<link rel="import" href="./buttress-db-realtime-handler.html">

<!-- TEMP HACK - Needs moving to component -->
<script src="./buttress-db-schema.js"></script>
<script src="./buttress-db-worker.js"></script>
<script src="../sugar/dist/sugar.js"></script>
<script src="../fingerprintjs2/dist/fingerprint2.min.js"></script>

<dom-module id="buttress-db">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <iron-ajax
      id="schema",
      url="[[endpoint]]/api/v1/app/schema",
      params="{{rqSchemaParams}}",
      handleAs="json",
      last-response="{{dbSchema}}",
      on-error="__dbSchemaError">
    </iron-ajax>

    <template id="dataServices" is="dom-repeat" items="{{__collections}}">
      <buttress-db-data-service
        id="[[item.name]]"
        token="[[token]]",
        api-path="[[apiPath]]",
        endpoint="[[endpoint]]",
        route="[[item.name]]",
        loaded="{{item.loaded}}",
        status="{{item.status}}",
        data="{{item.data}}",
        finger-print="{{__fingerPrint}}",
        metadata="{{item.metadata}}",
        priority="[[item.priority]]",
        core="[[item.core]]",
        auto-load>
      </buttress-db-data-service>
    </template>

    <buttress-db-realtime-handler
      token="[[token]]",
      endpoint="[[endpoint]]",
      app-id="[[appId]]",
      user-id="[[userId]]",
      db="{{db}}",
      logging="[[logging]]"
    ></buttress-db-realtime-handler>
  </template>
  <script>
    /**
     * `buttress-db`
     * #
     *
     * @customElement
     * @polymer
     */
    class ButtressDb extends Polymer.Element {
      static get is() { return 'buttress-db'; }
      static get properties() {
        return {
          endpoint: String,
          token: String,
          appId: String,
          apiPath: String,
          userId: String,

          logging: {
            type: Boolean,
            value: false
          },

          loaded: {
            type: Boolean,
            notify: true
          },
          loading: {
            type: Object,
            notify: true,
            value: function() {
              return {
                loaded: false,
                unpacking: false,
                current: 0,
                total: 0
              }
            }
          },
          error: {
            type: Boolean,
            notify: true
          },
          lastError: {
            type: Object,
            notify: true,
          },

          __maxConcurrentRequests: {
            type: Number,
            value: 4
          },
          rqSchemaParams: {
            type: Object
          },

          __fingerPrint: {
            type: Object,
            value: function() {
              return {
                machineId: null,
                processId: null,
                inc: null
              }
            }
          },

          dbSchema: {
            type: Array,
            value: function() {
              return [];
            }
          },
          db: {
            type: Object,
            value: function() {
              // post: {
              //   status: 'uninitialised',
              //   data: [],
              //   metadata: {}
              // }
              return {};
            },
            notify: true
          },
          coreCollections: {
            type: Array,
            value: function() {
              return [];
            },
          },
          __collections: {
            type: Object,
            value: function() {
              return [];
            },
            notify: true
          },
          __services: {
            type: Array,
            value: function() {
              return [];
            }
          },
          __numRequests: {
            type: Number,
            value: 0
          },

          settings: {
            type: Object,
            notify: true,
            value: function() {
              return {
                worker: false,
                local_sync: false,
                local_read: false,
                network_sync: false,
                network_read: true,
              };
            }
          },

          __localDB: {
            type: Object
          },
          __worker: {
            type: Object
          },
          __workerTasks: {
            type: Object,
            value: function() {
              return {};
            }
          },
          __workerId: {
            type: Number,
            value: 1
          }
        };
      }

      static get observers() {
        return [
          '__tokenChanged(token)',
          '__dbSchemaChanged(coreCollections, dbSchema.*)',
          '__settingChanged(settings.*)'
        ];
      }
      
      ready() {
        super.ready();
        this.addEventListener('data-service-list', ev => this.__onDataLoaded(ev));
        this.addEventListener('data-service-ready', ev => this.__dataServiceReady(ev));
      }
      
      connectedCallback() {
        super.connectedCallback();
        const settings = this.get('settings');

        if (!window.Fingerprint2) {
          throw new Error('User likely has ad block running, TODO: Display a better message');
          return;
        }

        new Fingerprint2().get(result => {
          let nibbles = result.match(/.{1}/g).map(n => parseInt(`0x${n}`, 16) > 7 ? 1 : 0);
          let id = 0;
          nibbles.forEach((n,idx) => id |= n << idx);
          this.set('__fingerPrint.machineId', id);
          this.set('__fingerPrint.processId', Math.floor(Math.random() * 100000) % 0xFFFF);
          this.set('__fingerPrint.inc', Math.floor(Math.random() * 65535) % 0xFFFF);
        });

        this.set('db.Factory', AppDb.Factory);

        // Check local storage settings
        if ('localStorage' in window) {
          Object.keys(settings).forEach((key) => {
            const value = this.getOption(key);
            if (value === undefined || value === null) return; // Skip and use default
            this.set(`settings.${key}`, value);
          });
        }
        
        if ('indexedDB' in window) {
          if (window.Buttress && window.Buttress.Worker && this.get('settings.worker')) {
            console.log('Talking to indexedDB via worker');
            const workerBlob = new Blob(['('+window.Buttress.Worker.toString()+')()'], {type: 'application/javascript'});

            try {
              const dbWorker = new Worker(URL.createObjectURL(workerBlob));
              dbWorker.onmessage = (ev) => this.__workerMessage(ev);
              dbWorker.onerror = (ev) => this.__workerError(ev);
              this.set('__worker', dbWorker);
            } catch (err) {
              console.error(err);
            }
          } else {
            console.log('Talking to indexedDB directly');
            this.set('__localDB', window.Buttress.Worker());
          }
        }
      }

      __settingChanged(cr) {
        const path = cr.path.split('.');
        if (!path || path.length !== 2) return;
        path.shift();

        this.setOption(path, cr.value);
      }

      __dataServiceReady(ev){
        const collections = this.get('__collections');

        this.push('__services', ev.detail);

        if (collections.length === this.get('__services.length')) {
          this.set('loading.current', 0);
          this.set('loading.total', this.get('__collections.length'));
          this.__services.sort((a,b) => a.priority - b.priority);
          for (let x=0; x < this.__maxConcurrentRequests; x++)
            this.__onDataLoaded();
        }
      }

      __tokenChanged() {
        const token = this.get('token');
        if (!token){
          return;
        }
        
        // Fetch app schema using provided token
        this.set('rqSchemaParams', {
          urq: Date.now(),
          token: token
        });
        this.$.schema.generateRequest();
      }

      __dbSchemaError(ev) {
        this.set('error', true);
        this.set('lastError', ev);
      }

      __dbSchemaChanged() {
        const schema = this.get('dbSchema');
        const coreCollections = this.get('coreCollections');
        if (!schema || schema.length < 1) return;

        AppDb.Schema.schema = schema;

        coreCollections.forEach(collection => {
          const key = Sugar.String.camelize(collection, false);
          const idx = this.push('__collections', {
            name: collection,
            status: 'uninitialised',
            priority: 1,
            data: [],
            core: true,
            metadata: {}
          }) - 1;
          this.set(['db', key], this.get(['__collections', idx]));
          this.linkPaths(['db', key], `__collections.${idx}`);
        });

        // Generate db data map
        schema.forEach(s => {
          const key = Sugar.String.camelize(s.name, false);
          const idx = this.push('__collections', {
            name: s.name,
            status: 'uninitialised',
            priority: 1,
            data: [],
            core: false,
            metadata: {}
          }) - 1;
          this.set(['db', key], this.get(['__collections', idx]));
          this.linkPaths(['db', key], `__collections.${idx}`);
        });

        if (this.get('__localDB')) {
          const collections = [].concat(schema).map(c => Sugar.String.camelize(c.name, false));
          this.get('__localDB').init({
            task: 'init',
            name: 'Buttress',
            version: 1,
            collections: collections
          })
          .then(() => {
            if (this.get('settings.local_read') === true) {
              this.__localLoadCollections(collections)
                .then(result => {
                  this.set('loaded', true);
                  this.set('loading.loaded', true);
                })
            }
          });
        }

        if (this.get('__worker')) {
          const collections = [].concat(schema).map(c => Sugar.String.camelize(c.name, false));
          this.__workerTask({
            task: 'init',
            name: 'Buttress',
            version: 1,
            collections: collections
          })
          .then(() => {
            if (this.get('settings.local_read') === true) {
              this.__workerLoadCollections(collections)
                .then(result => {
                  this.set('loaded', true);
                  this.set('loading.loaded', true);
                })
            }
          });
        }
      }

      __onDataLoaded(ev) {
        const services = this.get('__services');

        // No check for network load
        if (!this.get('settings.network_read')) {
          console.log('Data service disabled network call');
          return;
        }

        if (!ev && services.length > 0) {
          services.shift().triggerGet();
          this.__numRequests++;
          return;
        }

        if (--this.__numRequests === 0) {
          this.set('loaded', true);
          this.set('loading.loaded', true);
        }

        this.set('loading.current', this.get('loading.total') - this.get('__services.length') );
        this.set('loading.percent', (this.get('loading.current') / this.get('loading.total')) * 100);

        if (!services.length) {
          return;
        }

        services.shift().triggerGet();
        this.__numRequests++;
      }

      // Local Storage
      getOption(key) {
        if (!'localStorage' in window) return false;
        const value = window.localStorage.getItem(`buttress_${key}`);
        return typeof value == 'string' ? JSON.parse(value) : value;
      }
      setOption(key, value) {
        if (!'localStorage' in window) return false;
        window.localStorage.setItem(`buttress_${key}`, value);
      }

      // Worker IO
      clearCollections() {
        let method = null;

        if (this.get('__localDB')) method = (payload) => this.get('__localDB').clear(payload);
        if (this.get('__worker'))  method = (payload) => this.__workerTask(payload);

        if (!method) return;

        const results = this.get('__collections').reduce((out, collection) => {
          const collectionName = Sugar.String.camelize(collection.name, false);
          console.time(`Cleared ${collectionName}`);
          const promise = method({
            task: 'clear',
            collection: collectionName
          })
          .then(() => {
            console.timeEnd(`Cleared ${collectionName}`);
          });

          out.push(promise);
          return out;
        }, []);

        return Promise.all(results);
      }

      saveCollections() {
        let method = null;

        if (this.get('__localDB')) method = (payload) => this.get('__localDB').bulkWrite(payload);
        if (this.get('__worker'))  method = (payload) => this.__workerTask(payload);

        if (!method) return;

        const results = this.get('__collections').reduce((out, collection) => {
          const collectionName = Sugar.String.camelize(collection.name, false);
          console.time(`Write ${collection.data.length} to ${collectionName}`);
          const promise = method({
            task: 'bulkWrite',
            collection: collectionName,
            items: collection.data
          })
          .then(() => {
            console.timeEnd(`Write ${collection.data.length} to ${collectionName}`);
          });

          out.push(promise);
          return out;
        }, []);

        return Promise.all(results);
      }

      __localLoadCollections(collections) {
        console.log('__localLoadCollections', collections.length);
        const load = (collection) => {
          console.log(`local ${collection} load`);
          console.time(`local ${collection} loaded`);
          return this.get('__localDB').readAll({
            task: 'readAll',
            collection: collection
          })
          .then(data => {
            console.timeEnd(`local ${collection} loaded`);
            this.set(['db', collection, 'data'], data);
            this.set(['db', collection, 'loaded'], true);
          });
        };

        return Promise.all(collections.map(load));
      }

      __workerLoadCollections(collections) {
        const load = (collection) => {
          console.time(`local ${collection} loaded`);
          return this.__workerTask({
            task: 'readAll',
            collection: collection
          })
          .then(data => {
            console.timeEnd(`local ${collection} loaded`);
            this.set(['db', collection, 'data'], data.result);
            this.set(['db', collection, 'loaded'], true);
          });
        }

        return Promise.all(collections.map(load));
      }

      __workerTask(payload) {
        payload.id = this.get('__workerId');

        this.get('__worker').postMessage(payload);

        this.set('__workerId', this.get('__workerId') + 1);

        return new Promise((resolve, reject) => {
          this.set(`__workerTasks.${payload.id}`, {
            id: payload.id,
            resolve: resolve,
            reject: resolve
          });
        });
      }

      __workerMessage(ev) {
        const workerTasks = this.get('__workerTasks');
        const payload = ev.data;

        if (payload.id && workerTasks[payload.id]) {
          workerTasks[payload.id].resolve(payload);
          delete workerTasks[payload.id];
          return;
        }

        if (!payload.type) console.log(payload);

        switch(payload.type) {
          default:
            console.log(payload);
            break;
        }
      }
      __workerError(ev) {
        console.log('__workerError', ev);
      }
    }

    window.customElements.define(ButtressDb.is, ButtressDb);
  </script>
</dom-module>