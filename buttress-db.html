<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="./buttress-db-data-service.html">
<link rel="import" href="./buttress-db-realtime-handler.html">

<!-- TEMP HACK - Needs moving to component -->
<script src="./buttress-db-schema.js"></script>
<script src="../sugar/dist/sugar.js"></script>
<script src="../fingerprintjs2/dist/fingerprint2.min.js"></script>

<dom-module id="buttress-db">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <iron-ajax
      id="schema",
      url="[[endpoint]]/api/v1/app/schema",
      params="{{rqSchemaParams}}",
      handleAs="json",
      last-response="{{dbSchema}}",
      on-error="__dbSchemaError">
    </iron-ajax>

    <template id="dataServices" is="dom-repeat" items="{{__collections}}">
      <buttress-db-data-service
        id="[[item.name]]"
        token="[[token]]",
        endpoint="[[endpoint]]",
        route="[[item.name]]",
        loaded="{{item.loaded}}",
        status="{{item.status}}",
        data="{{item.data}}",
        finger-print="{{__fingerPrint}}",
        metadata="{{item.metadata}}",
        priority="[[item.priority]]">
      </buttress-db-data-service>
    </template>

    <buttress-db-realtime-handler
      token="[[token]]",
      endpoint="[[endpoint]]",
      app-id="[[appId]]",
      user-id="[[userId]]",
      db="{{db}}",
      logging="[[logging]]"
    ></buttress-db-realtime-handler>
  </template>
  <script>
    /**
     * `buttress-db`
     * #
     *
     * @customElement
     * @polymer
     */
    class ButtressDb extends Polymer.Element {
      static get is() { return 'buttress-db'; }
      static get properties() {
        return {
          endpoint: String,
          token: String,
          appId: String,
          userId: String,

          logging: {
            type: Boolean,
            value: false
          },

          loaded: {
            type: Boolean,
            notify: true
          },
          error: {
            type: Boolean,
            notify: true
          },
          lastError: {
            type: Object,
            notify: true,
          },

          __maxConcurrentRequests: {
            type: Number,
            value: 4
          },
          rqSchemaParams: {
            type: Object
          },

          __fingerPrint: {
            type: Object,
            value: function() {
              return {
                machineId: null,
                processId: null,
                inc: null
              }
            }
          },

          dbSchema: {
            type: Array,
            value: function() {
              return [];
            }
          },
          db: {
            type: Object,
            value: function() {
              // post: {
              //   status: 'uninitialised',
              //   data: [],
              //   metadata: {}
              // }
              return {};
            },
            notify: true
          },
          coreCollections: {
            type: Array,
            value: function() {
              return [];
            },
          },
          __collections: {
            type: Object,
            value: function() {
              return [];
            },
            notify: true
          },
          __services: {
            type: Array,
            value: function() {
              return [];
            }
          },
          __numRequests: {
            type: Number,
            value: 0
          }
        };
      }

      static get observers() {
        return [
          '__tokenChanged(token)',
          '__dbSchemaChanged(coreCollections, dbSchema.*)'
        ];
      }
      
      ready() {
        super.ready();
        this.addEventListener('data-service-list', ev => this.__onDataLoaded(ev));
        this.addEventListener('data-service-ready', ev => this.__dataServiceReady(ev));
      }
      
      connectedCallback() {
        new Fingerprint2().get(result => {
          let nibbles = result.match(/.{1}/g).map(n => parseInt(`0x${n}`, 16) > 7 ? 1 : 0);
          let id = 0;
          nibbles.forEach((n,idx) => id |= n << idx);
          this.set('__fingerPrint.machineId', id);
          this.set('__fingerPrint.processId', Math.floor(Math.random() * 100000) % 0xFFFF);
          this.set('__fingerPrint.inc', Math.floor(Math.random() * 65535) % 0xFFFF);
        });

        this.set('db.Factory', AppDb.Factory);
      }

      __dataServiceReady(ev){
        const collections = this.get('__collections');

        this.push('__services', ev.detail);

        if (collections.length === this.get('__services.length')) {
          this.__services.sort((a,b) => a.priority - b.priority);
          for (let x=0; x < this.__maxConcurrentRequests; x++)
            this.__onDataLoaded();
        }
      }

      __tokenChanged() {
        const token = this.get('token');
        if (!token){
          return;
        }
        
        // Fetch app schema using provided token
        this.set('rqSchemaParams', {
          urq: Date.now(),
          token: token
        });
        this.$.schema.generateRequest();
      }

      __dbSchemaError(ev) {
        this.set('error', true);
        this.set('lastError', ev);
      }

      __dbSchemaChanged() {
        const schema = this.get('dbSchema');
        const coreCollections = this.get('coreCollections');
        if (!schema || schema.length < 1) return;

        AppDb.Schema.schema = schema;

        coreCollections.forEach(collection => {
          const idx = this.push('__collections', {
            name: collection,
            status: 'uninitialised',
            priority: 1,
            data: [],
            metadata: {}
          }) - 1;
          this.set(['db', collection], this.get(['__collections', idx]));
          this.linkPaths(['db', collection], `__collections.${idx}`);
        });

        // Generate db data map
        schema.forEach(s => {
          const idx = this.push('__collections', {
            name: s.name,
            status: 'uninitialised',
            priority: 1,
            data: [],
            metadata: {}
          }) - 1;
          this.set(['db', s.name], this.get(['__collections', idx]));
          this.linkPaths(['db', s.name], `__collections.${idx}`);
        });
      }

      __onDataLoaded(ev) {
        const services = this.get('__services');

        if (!ev && services.length > 0) {
          services.shift().triggerGet();
          this.__numRequests++;
          return;
        }

        if (--this.__numRequests === 0) {
          this.set('loaded', true);
        }
        if (!services.length) {
          return;
        }

        services.shift().triggerGet();
        this.__numRequests++;
      }
    }

    window.customElements.define(ButtressDb.is, ButtressDb);
  </script>
</dom-module>